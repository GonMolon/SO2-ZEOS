1.a
La TSS se modifica al hacer un task_switch. Se tiene que guardar la dirección de la pila de kernel del proceso que se pasa a 
ejecutar, ya que la próxima vez que se entre en modo sistema mediante una interrupción, el hardware cogerá de la TSS esa 
dirección para setear el registro %esp. También se tiene que modificar al preparar init1, ya que init1 no se activa a través de un task_switch.

Fichero: sched.c
Línea: 83
Función: update_TSS

Llamada desde:

Fichero: sched.c
Línea: 90
Función: inner_task_switch
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Fichero: sched.c
Línea: 112
Función: init_task1

Obviamente también se modifica al iniciar el sistema. En ese momento, se guarda una dirección para la pila del kernel
para que la utilice en su inicialización. En ese momento también se guarda el número de segmento de datos del kernel, aunque 
no hará falta modificarlo luego.

1.b
Se actualiza cuando el proceso pasa de READY a RUN. También se debería de actualizar cuando se utiliza la llamada de sistema
get_stats consultando las estadísticas de este proceso en concreto.

Fichero: stats.c
Línea: 31
Función: update_stats

Llamada desde:

Fichero: sched.c
Línea: 199
Función: sched_next_rr
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Fichero: sys.c
Línea: 129
Función: sys_get_stats

1.c
La dirección lógica asignada es: 1081976 (0x108278).
La he encontrado imprimiéndola por pantalla con el siguiente código;

DWord pos = (DWord) &myVar;
char buff[15];
itoa(pos, buff);
write(1, buff, strlen(buff));

Su dirección física es:
